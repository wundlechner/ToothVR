"""
Copyright 2018 Andreas Wundlechner

GNU Lesser General Public License Usage
This file has to be used under the terms of the GNU Lesser
General Public License version 3 or later as published by the Free Software
Foundation and appearing in the file LICENSE included in the
packaging of this file. Please review the following information to
ensure the GNU Lesser General Public License version 3 requirements
will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
"""

import viz
import os
import re
import config as cfg
import random
import numpy

import sys
sys.path.append(cfg.path_to_paraview_libs)
import paraview.simple as pv
from paraview import vtk

import Controls

class Simulation_Data:
	"""
	This class takes care of everything concerning ParaView.
	Tasks there for are:
	- Controlling ParaView with commands
	- Reading data from ParaView
	- Convert the data to 3D models for Vizard
	"""
	def __init__(self, filename):
		"""
		Load the file and display it with default properties.
		"""
		# Load the file
		self.vtk_data = pv.OpenDataFile(filename)
		# Save applied filters to remove them when not needed anymore to release memory
		self._filters = [self.vtk_data]
		# Save a unaltered version of the data
		self.vtk_data_local = pv.servermanager.Fetch(self.vtk_data)
		# Init variables
		# ... for clipping function
		self.clip_origin = None
		self.clip_normal = None
		# ... for point cloud model
		self.cloud_point_size = 2
		# ... for switching between point cloud and surface model
		self._cycle_view_mode_buffer = False
		
		# ... for positioning the models
		self.origin_node = viz.addGroup()
		self.surface_node = viz.addGroup(parent=self.origin_node)
		self.cloud_node = viz.addGroup(parent=self.origin_node)
		# ... for registering the model parts
		self.surface_materials = {}
		self.cloud_materials = {}
		
		# Calculate the center of the data to move the model later to origin
		# bounding_box indices are found out by reading test data and compare it to ParaView standalone
		bounding_box = self.vtk_data_local.GetBounds()
		self._original_center = (
			(bounding_box[0]+bounding_box[1])/2,
			(bounding_box[2]+bounding_box[3])/2,
			(bounding_box[4]+bounding_box[5])/2)
		
		# Generate the models form the vtk data
		self.reload_models()


	def reload_models(self):
		self._clean_vizard_models()
		
		# Apply clip filter
		data = self._apply_clip(self.vtk_data)
		
		# Iterate over every material
		material_range = self.vtk_data_local.GetCellData().GetArray(cfg.material_name).GetRange()
		for material in range(int(material_range[0]), int(material_range[1])+1):
			# Separate the data by material
			material_data = pv.Threshold(Input=data)
			self._filters += [material_data]
			# Settings are generated mostly by ParaView Trace function
			material_data.Scalars = ['CELLS', cfg.material_name]
			material_data.ThresholdRange = [material, material]
			
			# Generate cloud
			local = pv.servermanager.Fetch(material_data)
			self.cloud_materials[material] = self.generate_cloud(local, cfg.coloring_name)
			self.cloud_materials[material].setParent(self.cloud_node)
			
			# Apply ExtractSurface and Triangulate filter
			extractSurface = pv.ExtractSurface(Input=material_data)
			self._filters += [extractSurface]
			# Settings are generated by ParaView Trace function
			extractSurface.PieceInvariant = 1
			extractSurface.NonlinearSubdivisionLevel = 1
			triangulate = pv.Triangulate(Input=extractSurface)
			self._filters += [triangulate]
			
			# Generate surface
			local = pv.servermanager.Fetch(triangulate)
			self.surface_materials[material] = self.generate_surface(local, cfg.coloring_name)
			self.surface_materials[material].setParent(self.surface_node)


	def _clean_vizard_models(self):
		"""
		Delete model related objects
		"""
		for child in self.cloud_node.getChildren():
			child.remove()
		for child in self.surface_node.getChildren():
			child.remove()
		self.surface_materials.clear()
		self.cloud_materials.clear()
		
	def _apply_clip(self, data):
		"""
		Apply the Clip filter to the data.
		Returns clipped data.
		"""
		# Apply clip only if needed
		if (not self.clip_normal is None) and (not self.clip_origin is None):
			data = pv.Clip(Input=data)
			self._filters += [data]
			# Settings are generated mostly by ParaView Trace function
			data.ClipType = 'Plane'
			data.Scalars = ['CELLS', cfg.coloring_name]
			data.Value = 17.925
			data.ClipType.Origin = self.clip_origin
			data.ClipType.Normal = self.clip_normal
		return data


	@staticmethod
	def _get_color(minimum, maximum, value):
		"""
		Calculate the color for the models with the given input.
		minimum: minimum value
		maximum: maximum value
		value: value between minimum and maximum
		"""
		# example:
		# _get_color(1, 5, 4)
		#
		# min		  middle		  max
		# blue		  white			  red
		#  |-------------|-------------|
		#				 |------|		 <-- percentage of red
		#        		 	    ^
		#					  value
		#
		# Returns: (1, 0.5, 0.5)
		minimum = float(minimum)
		maximum = float(maximum)
		value = float(value)
		
		middle = (minimum + maximum) / 2
		if value <= middle:
			# Calculate the color between blue and white
			percentage = (value - minimum) / (middle - minimum)
			return (percentage, percentage, 1)
		else:
			# Calculate the color between white and red
			percentage = (value - middle) / (maximum - middle)
			return (1, 1 - percentage, 1 - percentage)


	def generate_cloud(self, data, color_array_name):
		"""
		Render the vtk data as a cloud, centered at origin and return the Vizard object.
		color_array_name defines the name of the CellData array (for example: "equivalent_stress" or "material")
		"""
		# Start creating the model
		viz.startLayer(viz.POINTS)
		viz.pointSize(self.cloud_point_size)
		# Use the range of the complete data set to ensure consitency
		minimum, maximum = self.vtk_data_local.GetCellData().GetArray(color_array_name).GetRange()
		
		# Generate cloud model by iterating over every cell
		num_of_cells = data.GetNumberOfCells()
		for i in range(num_of_cells):
			cell = data.GetCell(i)
			
			# Calculate the center of the cell
			x=0.0; y=0.0; z=0.0
			num_of_points = cell.GetNumberOfPoints()
			for j in range(num_of_points):
				point = cell.GetPoints().GetPoint(j)
				x += point[0]
				y += point[1]
				z += point[2]
			x /= num_of_points
			y /= num_of_points
			z /= num_of_points
			
			# Get the value of the cell for color calculation
			value = data.GetCellData().GetArray(color_array_name).GetValue(i)
			color = Simulation_Data._get_color(minimum, maximum, value)
			viz.vertexColor(color[0], color[1], color[2])
			# Draw the point
			viz.vertex(x,y,z)
		
		# Finish the model
		model = viz.endLayer()
		# Set the center of the model to (0, 0, 0)
		model.setPosition(
			-(self._original_center[0]),
			-(self._original_center[1]),
			-(self._original_center[2]))
		# Create group to get a centered model with coordinates (0, 0, 0)
		group = viz.addGroup()
		model.setParent(group)
		return group


	def generate_surface(self, data, color_array_name):
		"""
		Render the vtk data as a surface, centered at origin and return the Vizard object.
		color_array_name defines the name of the CellData array (for example: "equivalent_stress" or "material")
		"""
		# Start creating the model
		viz.startLayer(viz.TRIANGLES)
		# Use the range of the complete data set to ensure consitency
		minimum, maximum = self.vtk_data_local.GetCellData().GetArray(color_array_name).GetRange()
		
		# Generate surface model by iterating over every polygon
		polys = data.GetPolys()
		polys.InitTraversal()
		id_list = vtk.vtkIdList()
		cell = polys.GetNextCell(id_list)
		while not cell == 0:
			# Get the value of the cell for color calculation
			value = data.GetCellData().GetArray(color_array_name).GetValue(polys.GetTraversalLocation()/4)
			color = Simulation_Data._get_color(minimum, maximum, value)
			viz.vertexColor(color[0], color[1], color[2])
			
			# Read the points (po) of the polygon
			po = []
			for j in range(id_list.GetNumberOfIds()):
				po.append(data.GetPoints().GetPoint(id_list.GetId(j)))
			
			# Calculate the normal vector of the polygon
			# Normal vector is needed for better lighting
				# Calculate the coss product of vectors from point 0 to 1 and 0 to 2
			ab = (po[1][0]-po[0][0], po[1][1]-po[0][1], po[1][2]-po[0][2])
			ac = (po[2][0]-po[0][0], po[2][1]-po[0][1], po[2][2]-po[0][2])
			normal = numpy.cross(ab, ac)
				# Set the magnitude of the normal vector to 1
			normal = normal/numpy.linalg.norm(normal)
			# Create the polygon with the normal vector and the points
			viz.normal(normal[0], normal[1], normal[2])
			for position in po:
				viz.vertex(position[0],position[1],position[2])
			cell = polys.GetNextCell(id_list)
		
		# Finish the model
		model = viz.endLayer()
		# Enable lighting for the model (Shadows aren't needed)
		model.enable(viz.LIGHTING)
		model.disable(viz.SHADOW_CASTING)
		model.disable(viz.SHADOWS)
		# Set the center of the model to (0, 0, 0)
		model.setPosition(
			-(self._original_center[0]),
			-(self._original_center[1]),
			-(self._original_center[2]))
		# Create group to get a centered model with coordinates (0, 0, 0)
		group = viz.addGroup()
		model.setParent(group)
		return group


	def cycle_view_mode(self):
		"""
		This function cycles through the different view modes.
		It acts like a shift register where the last bit is the input of the first.
		110 -> 011 -> 101 -> 110
		"""
		tmp = self.cloud_node.getVisible()
		self.cloud_node.visible(self.surface_node.getVisible())
		self.surface_node.visible(self._cycle_view_mode_buffer)
		self._cycle_view_mode_buffer = tmp


	def get_cloud_point_size(self):
		"""
		Returns the current size of the point cloud points.
		"""
		return self.cloud_point_size


	def set_cloud_point_size(self, point_size=1):
		"""
		Sets the current size of the point cloud points.
		This function also updates the point cloud model.
		"""
		self.cloud_point_size = point_size
		# update the models of the different materials
		for key in self.cloud_materials.keys():
			old_model = self.cloud_materials[key].getChildren()[0]
			# Create new model
			viz.startLayer(viz.POINTS)
			viz.pointSize(point_size)
			# Copy the old model with new point_size
			for point_id in range(old_model.getVertexCount()):
				viz.vertexColor(old_model.getVertexColor(point_id))
				viz.vertex(old_model.getVertex(point_id))
			model = viz.endLayer()
			# Replace the old model with the new one
			model.setParent(self.cloud_materials[key])
			model.setPosition(old_model.getPosition())
			model.setScale(old_model.getScale())
			model.setEuler(old_model.getEuler())
			old_model.remove()


	def toggle_material(self, number):
		"""
		Toggle the visibilty of the different materials.
		"""
		if number in self.cloud_materials.keys():
			self.cloud_materials[number].visible(not self.cloud_materials[number].getVisible())
			self.surface_materials[number].visible(not self.surface_materials[number].getVisible())


	def get_material_range(self):
		"""
		Returns the range of different materials.
		"""
		return self.vtk_data_local.GetCellData().GetArray(cfg.material_name).GetRange()


	def get_probe_value(self, position):
		"""
		Returns the value on the probe location.
		"""
		# Apply ProbeLocation filter with configruation found by ParaView Trace function
		probeLocation = pv.ProbeLocation(Input=self.vtk_data, ProbeType='Fixed Radius Point Source')
		self._filters += [probeLocation]
		probeLocation.ProbeType.Center = position
		
		local = pv.servermanager.Fetch(probeLocation)
		return local.GetPointData().GetScalars(cfg.coloring_name).GetValue(0)


	def remove(self):
		"""
		Reset ParaView and Vizard stuff to default.
		"""
		self.origin_node.remove()
		for filter in reversed(self._filters):
			pv.Delete(filter)
		pv.servermanager.ProxyManager().UnRegisterProxies()
		pv.Disconnect()
		pv.Connect()



# Code to test the behaviour. (No functionality for the project)
daten = None
if __name__ == "__main__":
	import viz
	viz.go()
	daten = Simulation_Data("C:\\Programmierzeug\\Testdaten\\test.vtk")
	print("Loaded vtk")
